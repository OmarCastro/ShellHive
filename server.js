// Generated by LiveScript 1.2.0
(function(){
  var express, jade, fs, util, spawn, stylus, nib, CommandProcess, CommandLine, app, file, flow, pendingWrite, saveflow, io, join$ = [].join;
  express = require('express');
  jade = require('jade');
  fs = require('fs');
  util = require('util');
  spawn = require('child_process').spawn;
  stylus = require('stylus');
  nib = require('nib');
  CommandProcess = (function(){
    CommandProcess.displayName = 'CommandProcess';
    var prototype = CommandProcess.prototype, constructor = CommandProcess;
    function CommandProcess(exec, args, nodeId){
      this.exec = exec;
      this.args = args;
      this.hasPipe = false;
      this.isClosed = true;
      this.nextProcess = null;
      this.captureStdout = false;
      this.nodeId = nodeId;
      this.lineCommand = '';
    }
    prototype.commandString = function(){
      var args, i$, ref$, len$, x;
      args = [];
      for (i$ = 0, len$ = (ref$ = this.args).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (x.indexOf(' ') === -1) {
          args.push(x);
        } else {
          args.push("\"" + x + "\"");
        }
      }
      return this.exec + " " + join$.call(args, ' ');
    };
    prototype.onErrData = function(data){
      this.errdata += data;
    };
    prototype.onOutData = function(data){
      var nextProc;
      this.outdata += data.toString('utf8');
      nextProc = this.nextProcess;
      if (nextProc) {
        if (!nextProc.isClosed) {
          nextProc.spawn.stdin.write(data);
        }
      }
    };
    prototype.onSpawnClosed = function(code){
      var nextProc;
      console.log('the process', this.commandString(), ' closed');
      if (code !== 0) {
        io.sockets['in']('helpers').emit('error', {
          id: this.nodeId,
          commandline: this.lineCommand,
          content: this.errdata
        });
      }
      if (this.captureStdout) {
        io.sockets['in']('helpers').emit('stdout', {
          id: this.nodeId,
          commandline: this.lineCommand,
          content: this.outdata
        });
      }
      nextProc = this.nextProcess;
      if (nextProc) {
        if (!nextProc.isClosed) {
          nextProc.spawn.stdin.end();
        }
      }
      this.isClosed = true;
    };
    prototype.run = function(){
      var pr, x$;
      this.isClosed = false;
      this.errdata = "";
      this.outdata = "";
      pr = this;
      x$ = this.spawn = spawn(this.exec, this.args);
      x$.stdout.on('data', function(it){
        return pr.onOutData(it);
      });
      x$.stderr.on('data', function(it){
        return pr.onErrData(it);
      });
      x$.on('close', function(it){
        return pr.onSpawnClosed(it);
      });
      return x$;
    };
    return CommandProcess;
  }());
  CommandLine = (function(){
    CommandLine.displayName = 'CommandLine';
    var prototype = CommandLine.prototype, constructor = CommandLine;
    function CommandLine(exec, args, nodeId){
      var x$, newProcess;
      x$ = newProcess = new CommandProcess(exec, args, nodeId);
      x$.captureStdout = true;
      x$.lineCommand = newProcess.commandString();
      this.processes = [newProcess];
    }
    prototype.pipe = function(exec, args, nodeId){
      var lastprocess, x$, newProcess;
      lastprocess = this.processes[this.processes.length - 1];
      x$ = newProcess = new CommandProcess(exec, args, nodeId);
      x$.captureStdout = true;
      x$.lineCommand = lastprocess.commandString() + " | " + newProcess.commandString();
      this.processes.push(newProcess);
      lastprocess.nextProcess = newProcess;
      return this;
    };
    prototype.run = function(){
      var i$, ref$, len$, x, results$ = [];
      for (i$ = 0, len$ = (ref$ = this.processes).length; i$ < len$; ++i$) {
        x = ref$[i$];
        results$.push(x.run());
      }
      return results$;
    };
    prototype.captureProcess = function(num){
      this.processes[num].captureStdout = true;
    };
    prototype.commandString = function(){
      var x;
      return (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = this.processes).length; i$ < len$; ++i$) {
          x = ref$[i$];
          results$.push(x.commandString());
        }
        return results$;
      }.call(this)).join(' | ');
    };
    return CommandLine;
  }());
  app = express();
  file = __dirname + '/flow.json';
  flow = {};
  fs.readFile(file, 'utf8', function(err, data){
    if (err) {
      return console.log('Error: ' + err);
    }
    return flow = JSON.parse(data);
  });
  pendingWrite = false;
  saveflow = function(){
    fs.writeFile(file, JSON.stringify(flow, null, 4), function(err){
      if (err) {
        console.log(err);
      } else {
        console.log("The file was saved!");
      }
      pendingWrite = false;
    });
  };
  io = require('socket.io').listen(
  app.listen(8000));
  app.set('views', __dirname + '/views');
  app.set('view engine', 'jade');
  app.set('view options', {
    layout: false
  });
  app.configure(function(){
    app.use(stylus.middleware({
      src: __dirname + '/views',
      dest: __dirname + '/public',
      compile: function(str, path, fn){
        return stylus(str).set('filename', path).set('compress', true).render(fn);
      }
    }));
    app.use(
    express['static'](
    __dirname + '/public'));
    app.use(
    express['static'](
    __dirname + '/bower_components'));
  });
  app.get('/', function(req, res){
    res.render('home.jade');
  });
  app.get('/helper', function(req, res){
    res.render('helper.jade');
  });
  io.sockets.on('connection', function(socket){
    socket.on('graph-user', function(data){
      socket.join('graph-users');
      socket.emit('flowData', flow);
    });
    socket.on('helper', function(data){
      socket.join('helpers');
    });
    socket.on('run-app', function(data){
      var x$, line;
      x$ = line = new CommandLine('cat', ["nodes.txt"]).pipe("grep", ["cat"]);
      x$.captureProcess(0);
      x$.run();
    });
    socket.on('nodePosChanged', function(data){
      var x$;
      x$ = flow.nodes[data.id];
      x$.x = data.x;
      x$.y = data.y;
      socket.broadcast.to('graph-users').emit('nodePosChanged', data);
      if (!pendingWrite) {
        pendingWrite = setTimeout(saveflow, 1000);
      }
    });
  });
}).call(this);
