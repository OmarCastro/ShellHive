// Generated by LiveScript 1.2.0
(function(){
  app.directive("graphModel", function($document){
    return {
      restrict: 'A',
      replace: false,
      scope: {
        graphModel: '=',
        options: '='
      },
      controller: [
        '$scope', '$element', '$modal', '$attrs', function(scope, element, $modal, attr){
          var pointerId, scale, graphX, graphY, startX, startY, edgeIniX, edgeIniY, elem, graphModel, res$, key, ref$, val, x$, nodesElem, edgesElem, svgElem, $svgElem, nodesElemStyle, edgesElemStyle, popup, $popup, popupHeight, $popupInput, update, mousemove, mouseup, newComponent, newMacroComponent, newCommandComponent, mapMouseToScene, mapMouseToView, mapPointToScene, scaleFromMouse, MouseWheelHandler, mousewheelevt, simpleEdge, setEdgePath, popupState, startEdge, moveEdge, endEdge, showPopup, popupSubmit, hidePopup, hidePopupAndEdge, y$;
          pointerId = 0;
          scale = 1;
          graphX = 0;
          graphY = 0;
          startX = 0;
          startY = 0;
          edgeIniX = 0;
          edgeIniY = 0;
          elem = element[0];
          graphModel = scope.graphModel;
          graphModel.macros = {
            sss: shellParser.createMacro('sss', 'ddd')
          };
          res$ = [];
          for (key in ref$ = graphModel.macros) {
            val = ref$[key];
            res$.push(key);
          }
          graphModel.macroList = res$;
          x$ = scope;
          x$.popupText = '';
          x$.graph = this;
          x$.$watch("graphModel", function(){
            return scope.visualData = scope.graphModel;
          });
          x$.visualData = scope.graphModel;
          x$.implementedCommands = listOfImplementedCommands;
          x$.isImplemented = isImplemented;
          x$.isArray = angular.isArray;
          x$.isString = angular.isString;
          x$.swapPrevious = function(array, index, id){
            var ref$, i$, len$, connection, results$ = [];
            if (index === 0) {
              return;
            }
            ref$ = [array[index - 1], array[index]], array[index] = ref$[0], array[index - 1] = ref$[1];
            for (i$ = 0, len$ = (ref$ = scope.visualData.connections).length; i$ < len$; ++i$) {
              connection = ref$[i$];
              if (connection.endNode === id) {
                if (connection.endPort === "file" + index) {
                  results$.push(connection.endPort = "file" + (index - 1));
                } else if (connection.endPort === "file" + (index - 1)) {
                  results$.push(connection.endPort = "file" + index);
                }
              }
            }
            return results$;
          };
          nodesElem = elem.querySelector(".nodes");
          edgesElem = elem.querySelector(".edges");
          svgElem = elem.querySelector("svg");
          $svgElem = $(svgElem);
          nodesElemStyle = nodesElem.style;
          edgesElemStyle = edgesElem.style;
          popup = elem.querySelector(".popup");
          $popup = $(popup);
          popupHeight = $popup.height();
          $popup.hide();
          $popupInput = $popup.find("input");
          update = function(){
            var transform;
            transform = "translate(" + graphX + "px, " + graphY + "px) scale(" + scale + ")";
            nodesElemStyle[cssTransform] = transform;
            return edgesElemStyle[cssTransform] = transform;
          };
          update();
          mousemove = function(ev){
            var event;
            event = ev.originalEvent;
            graphX += event.screenX - startX;
            graphY += event.screenY - startY;
            startX = event.screenX;
            startY = event.screenY;
            update();
          };
          mouseup = function(){
            var x$;
            pointerId = 0;
            x$ = $document;
            x$.unbind("pointermove", mousemove);
            x$.unbind("pointerup", mouseup);
            return x$;
          };
          element.bind("pointerdown", function(ev){
            var event, targetTag, x$;
            if (ev.which === 3) {
              return false;
            }
            event = ev.originalEvent;
            targetTag = event.target.tagName;
            if (pointerId || (targetTag === 'INPUT' || targetTag === 'SELECT' || targetTag === 'LABEL' || targetTag === 'A' || targetTag === 'LI')) {
              return;
            }
            hidePopupAndEdge();
            pointerId = event.pointerId;
            x$ = $document;
            x$.bind("pointermove", mousemove);
            x$.bind("pointerup", mouseup);
            startX = event.screenX;
            startY = event.screenY;
            event.preventDefault();
            event.stopPropagation();
          });
          newComponent = function(content, position){
            if (in$(content.split(" ")[0], listOfImplementedCommands)) {
              return newCommandComponent(content, position);
            } else {
              return newMacroComponent(content, position);
            }
          };
          newMacroComponent = function(name, position){
            var visualData, newComponent;
            visualData = scope.visualData;
            newComponent = {
              type: 'subgraph',
              macro: graphModel.macros[name],
              id: visualData.counter++,
              position: {}
            };
            visualData.components.push(newComponent);
            importAll$(newComponent.position, position);
            return newComponent;
          };
          newCommandComponent = function(command, position){
            var visualData, newResult, x$, newComponent;
            console.log(command);
            visualData = scope.visualData;
            newResult = shellParser.parseCommand(command);
            x$ = newComponent = newResult.components[0];
            x$.id = visualData.counter++;
            importAll$(x$.position, position);
            visualData.components.push(newComponent);
            return newComponent;
          };
          mapMouseToScene = function(event){
            var ref$, x, y;
            ref$ = mapMouseToView(event), x = ref$.x, y = ref$.y;
            return mapPointToScene(x, y);
          };
          mapMouseToView = function(event){
            var offset;
            offset = $svgElem.offset();
            return {
              x: event.pageX - offset.left,
              y: event.pageY - offset.top
            };
          };
          mapPointToScene = function(x, y){
            return {
              x: (x - graphX) / scale,
              y: (y - graphY) / scale
            };
          };
          scaleFromMouse = function(amount, event){
            var ref$, x, y, relpointX, relpointY;
            if ((scale < 0.2 && amount < 1) || (scale > 20 && amount > 1)) {
              return;
            }
            hidePopupAndEdge();
            ref$ = mapMouseToView(event), x = ref$.x, y = ref$.y;
            relpointX = x - graphX;
            relpointY = y - graphY;
            graphX += Math.round(-relpointX * amount + relpointX);
            graphY += Math.round(-relpointY * amount + relpointY);
            scale *= amount;
            update();
          };
          MouseWheelHandler = function(event){
            if (!event.altKey) {
              return;
            }
            event.preventDefault();
            event.stopPropagation();
            if ((event.wheelDelta || -event.detail) > 0) {
              return scaleFromMouse(1.1, event);
            } else {
              return scaleFromMouse(0.9, event);
            }
          };
          mousewheelevt = /Firefox/i.test(navigator.userAgent) ? "DOMMouseScroll" : "mousewheel";
          elem.addEventListener(mousewheelevt, MouseWheelHandler, false);
          simpleEdge = element.find('.emptyEdge')[0];
          setEdgePath = function(iniX, iniY, endX, endY){
            var xpoint;
            xpoint = (endX - iniX) / 4;
            return simpleEdge.setAttribute('d', "M " + iniX + " " + iniY + " H " + (iniX + 0.5 * xpoint) + " C " + (iniX + 2 * xpoint) + "," + iniY + " " + (iniX + xpoint * 2) + "," + endY + " " + (iniX + xpoint * 4) + "," + endY + " H " + endX);
          };
          popupState = {
            x: 0,
            y: 0,
            startNode: 0,
            startPort: 0
          };
          startEdge = function(elem, position, ev){
            this.hidePopup();
            edgeIniX = elem.offsetLeft + position.x;
            edgeIniY = elem.offsetTop + elem.offsetHeight * 0.75 + position.y;
            return setEdgePath(edgeIniX, edgeIniY, edgeIniX, edgeIniY);
          };
          moveEdge = function(event){
            var ref$, x, y;
            ref$ = mapMouseToScene(event), x = ref$.x, y = ref$.y;
            return setEdgePath(edgeIniX, edgeIniY, x, y);
          };
          endEdge = function(){
            console.log("edge finished");
            return simpleEdge.setAttribute('d', "M 0 0");
          };
          showPopup = function(event, startNode, startPort){
            var ref$, x, y, x$;
            scope.popupText = '';
            ref$ = mapMouseToView(event), x = ref$.x, y = ref$.y;
            importAll$(popupState, {
              x: x,
              y: y
            });
            x$ = popupState;
            x$.startNode = startNode;
            x$.startPort = startPort;
            console.log(popupHeight / 2);
            popup.style[cssTransform] = "translate(" + Math.floor(x) + "px," + Math.floor(y - popupHeight / 2) + "px)";
            $popup.show();
            $popupInput.focus();
            return scope.$digest();
          };
          popupSubmit = function(content){
            var comp;
            comp = newComponent(content, popupState);
            scope.visualData.connections.push({
              startNode: popupState.startNode,
              startPort: popupState.startPort,
              endNode: comp.id,
              endPort: 'input'
            });
            hidePopup();
            return endEdge();
          };
          hidePopup = function(){
            return $popup.hide();
          };
          hidePopupAndEdge = function(){
            $popup.hide();
            return endEdge();
          };
          y$ = this;
          y$.isFreeSpace = function(elem){
            return elem === svgElem || elem === nodesElem;
          };
          y$.showPopup = showPopup;
          y$.nodesElement = nodesElem;
          y$.popupSubmit = popupSubmit;
          y$.hidePopup = hidePopup;
          y$.hidePopupAndEdge = hidePopupAndEdge;
          y$.nodesElement = nodesElem;
          y$.newCommandComponent = newCommandComponent;
          y$.startEdge = startEdge;
          y$.moveEdge = moveEdge;
          y$.endEdge = endEdge;
          y$.updateScope = function(){
            return scope.$digest();
          };
          y$.getVisualData = function(){
            return scope.visualData;
          };
          y$.mapPointToScene = mapPointToScene;
          y$.mapMouseToScene = mapMouseToScene;
          y$.mapMouseToView = mapMouseToView;
          y$.setGraphView = function(view){
            hidePopupAndEdge();
            scope.visualData = view;
          };
          y$.revertToRoot = function(){
            scope.visualData = graphModel;
          };
          y$.newMacro = function(name, descr){
            var res$, key;
            graphModel.macros[name] = shellParser.createMacro(name, descr);
            res$ = [];
            for (key in graphModel.macros) {
              res$.push(key);
            }
            graphModel.macroList = res$;
          };
          y$.translateNode = function(id, position, x, y){
            var i$, ref$, len$, el;
            position.x += x / scale;
            position.y += y / scale;
            for (i$ = 0, len$ = (ref$ = edgesElem.querySelectorAll("[connector]")).length; i$ < len$; ++i$) {
              el = ref$[i$];
              $(el).scope().updateWithId(id);
            }
          };
        }
      ]
    };
  });
  app.directive("connector", function($document){
    return {
      scope: true,
      link: function(scope, element, attr){
        var StartPortOffset, EndPortOffset, startPosition, endPosition, startComponent, endComponent, dataedge, elem, $graphElement, resultScope, graphElement, i$, ref$, len$, component, setEdgePath, update;
        dataedge = scope.$parent.edge;
        elem = element[0];
        $graphElement = element.closest('[graph-model]');
        resultScope = $graphElement.scope();
        graphElement = $graphElement[0];
        for (i$ = 0, len$ = (ref$ = resultScope.visualData.components).length; i$ < len$; ++i$) {
          component = ref$[i$];
          if (component.id === dataedge.startNode) {
            startComponent = component;
            startPosition = component.position;
            break;
          }
        }
        for (i$ = 0, len$ = (ref$ = resultScope.visualData.components).length; i$ < len$; ++i$) {
          component = ref$[i$];
          if (component.id === dataedge.endNode) {
            endComponent = component;
            endPosition = component.position;
            break;
          }
        }
        setEdgePath = function(iniX, iniY, endX, endY){
          var xpoint;
          xpoint = (endX - iniX) / 4;
          return elem.setAttribute('d', "M " + iniX + " " + iniY + " H " + (iniX + 0.5 * xpoint) + " C " + (iniX + 2 * xpoint) + "," + iniY + " " + (iniX + xpoint * 2) + "," + endY + " " + (iniX + xpoint * 4) + "," + endY + " H " + endX);
        };
        update = function(){
          return setEdgePath(startPosition.x + StartPortOffset.left, startPosition.y + StartPortOffset.top, endPosition.x + EndPortOffset.left, endPosition.y + EndPortOffset.top);
        };
        scope.update = update;
        scope.updateWithId = function(id){
          if (dataedge.startNode === id || dataedge.endNode === id) {
            update();
          }
        };
        scope.reset = function(){
          var Startnode, StartPort, Endnode, EndPort;
          Startnode = graphElement.querySelector(".nodes .component[data-node-id='" + dataedge.startNode + "']");
          StartPort = Startnode.querySelector(".box[data-port='" + dataedge.startPort + "']");
          Endnode = graphElement.querySelector(".nodes .component[data-node-id='" + dataedge.endNode + "']");
          EndPort = Endnode.querySelector(".box[data-port='" + dataedge.endPort + "']");
          StartPortOffset = {
            top: StartPort.offsetTop + StartPort.offsetHeight * 0.75,
            left: StartPort.offsetLeft
          };
          EndPortOffset = {
            top: EndPort.offsetTop + EndPort.offsetHeight * 0.75,
            left: EndPort.offsetLeft
          };
          return update();
        };
        requestAnimationFrame(function(){
          scope.$watch('edge.endPort', function(){
            return scope.reset();
          });
          return scope.reset();
        });
      }
    };
  });
  app.directive("component", function($document){
    var pointerId;
    pointerId = 0;
    return {
      require: '^graphModel',
      scope: true,
      link: function(scope, element, attr, graphModelController){
        var datanode, startX, startY, title, position, elem, imstyle, mousemove, moveBy, mouseup;
        scope.transform = cssTransform.replace(/[A-Z]/g, function(v){
          return "-" + v.toLowerCase();
        });
        datanode = scope.$parent.data;
        startX = 0;
        startY = 0;
        title = datanode.title;
        position = datanode.position;
        elem = element[0];
        imstyle = elem.style;
        element.bind("pointerdown", function(ev){
          var event, targetTag, pointerId, x$;
          switch (ev.which) {
          case 2:
            return true;
          case 3:
            return false;
          }
          graphModelController.hidePopupAndEdge();
          event = ev.originalEvent;
          targetTag = event.target.tagName;
          if (pointerId || (targetTag === 'INPUT' || targetTag === 'SELECT' || targetTag === 'LABEL')) {
            return;
          }
          pointerId = event.pointerId;
          x$ = $document;
          x$.bind("pointermove", mousemove);
          x$.bind("pointerup", mouseup);
          startX = event.screenX;
          startY = event.screenY;
          return false;
        });
        mousemove = function(ev){
          var event;
          event = ev.originalEvent;
          moveBy(event.screenX - startX, event.screenY - startY);
          startX = event.screenX;
          startY = event.screenY;
        };
        moveBy = function(x, y){
          graphModelController.translateNode(datanode.id, position, x, y);
          scope.$digest();
        };
        mouseup = function(){
          var pointerId, x$;
          pointerId = 0;
          x$ = $document;
          x$.unbind("pointermove", mousemove);
          x$.unbind("pointerup", mouseup);
          return x$;
        };
      }
    };
  });
  app.directive("port", function($document){
    return {
      require: '^graphModel',
      scope: true,
      link: function(scope, element, attr, graphModelController){
        var datanode, title, position, elem, imstyle, ref$, ConnectIfOk, mousemove, mouseup;
        datanode = scope.$parent.data;
        title = datanode.title;
        position = datanode.position;
        elem = element[0];
        imstyle = elem.style;
        scope.componentId = datanode.id;
        scope.isOutputNode = (ref$ = attr.port) === 'output' || ref$ === 'error' || ref$ === 'retcode';
        element.bind("pointerdown", function(ev){
          var event, x$;
          console.log(ev);
          event = ev.originalEvent;
          graphModelController.startEdge(elem, position, event);
          x$ = $document;
          x$.bind("pointermove", mousemove);
          x$.bind("pointerup", mouseup);
          return false;
        });
        ConnectIfOk = function(startNode, startPort, endNode, endPort){
          var visualData, isOk, i$, ref$, len$, x;
          visualData = graphModelController.getVisualData();
          isOk = true;
          for (i$ = 0, len$ = (ref$ = visualData.connections).length; i$ < len$; ++i$) {
            x = ref$[i$];
            if ((x.startNode === endNode && x.endNode === startNode) || (x.startNode === startNode && x.endNode === endNode)) {
              isOk = false;
              break;
            }
          }
          if (isOk) {
            visualData.connections.push({
              startNode: startNode,
              startPort: startPort,
              endNode: endNode,
              endPort: endPort
            });
            graphModelController.updateScope();
          }
        };
        mousemove = function(ev){
          graphModelController.moveEdge(ev.originalEvent);
        };
        mouseup = function(ev){
          var event, pointedElem, $pointedElem, outAttr, outPortScope, x$;
          event = ev.originalEvent;
          pointedElem = document.elementFromPoint(event.clientX, event.clientY);
          $pointedElem = $(pointedElem);
          if (graphModelController.isFreeSpace(pointedElem)) {
            graphModelController.showPopup(event, scope.componentId, attr.port);
          } else {
            graphModelController.endEdge();
            outAttr = $pointedElem.attr("data-port");
            if (outAttr) {
              outPortScope = $pointedElem.scope();
              if (scope.isOutputNode !== outPortScope.isOutputNode) {
                if (scope.isOutputNode) {
                  ConnectIfOk(scope.componentId, attr.port, outPortScope.componentId, outAttr);
                } else {
                  ConnectIfOk(outPortScope.componentId, outAttr, scope.componentId, attr.port);
                }
              }
            }
          }
          x$ = $document;
          x$.unbind("pointermove", mousemove);
          x$.unbind("pointerup", mouseup);
        };
      }
    };
  });
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
